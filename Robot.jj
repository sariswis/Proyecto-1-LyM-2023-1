/**
 * SECTION 1: PARSER
 */

options
{
  STATIC = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.util.HashMap;
import java.lang.String;
import java.util.ArrayList;

public class Robot 
{
	private RobotWorldDec world;
	public String salida = new String();

	private static HashMap variables = new HashMap();
	private static HashMap functions = new HashMap();
	private static ArrayList params = new ArrayList();
	
	public void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	public static void addVariable(Token token){
		String def = "";
        String image = token.image.toLowerCase();
        variables.put(image, def);
	}

	public static void addParam(Token token){
        String image = token.image.toLowerCase();
        params.add(image);
	}

	public static void assignVariable(Token number, Token token){
        Integer num = Integer.parseInt(number.image.toLowerCase());
        String image = token.image.toLowerCase();
		if (variables.containsKey(image)){
			variables.put(image, num);
		} else {
			throw new Error("Couldn't assign " + number.image + " to undefined variable " + token.image + "\nLine: " + token.beginLine + " Column: " + token.beginColumn);
		}
	}
    
	public static void checkVariable(Token token){
		if (!params.contains(token.image)){
			if (variables.containsKey(token.image)){
				String value = (String) variables.get(token.image);
				if (value == ""){
					throw new Error("The variable " + token.image + " has no value\nLine: " + token.beginLine + " Column: " + token.beginColumn);
				}
			} else {
				throw new Error("The variable " + token.image + " is not defined\nLine: " + token.beginLine + " Column: " + token.beginColumn);
			}
		}
	}

	public static void checkVariableF(Token token){
		if (variables.containsKey(token.image)){
			String value = (String) variables.get(token.image);
			if (value == ""){
				throw new Error("The variable " + token.image + " has no value\nLine: " + token.beginLine + " Column: " + token.beginColumn);
			}
		} else {
			throw new Error("The variable " + token.image + " is not defined\nLine: " + token.beginLine + " Column: " + token.beginColumn);
		}
	}

	public static void addFunction(Token token){
		String image = token.image.toLowerCase();
		functions.put(image, "");
	}

    public static void callFunction(Token token, ArrayList list){
		if (functions.containsKey(token.image)){

		} else {
			throw new Error("The function " + token.image + " is not defined\nLine: " + token.beginLine + " Column: " + token.beginColumn);
		}
	}

	class Function {
	private String name;
	private HashMap params = new HashMap();
	private ArrayList<Instruction> instructions =  new ArrayList<Instruction>();
	
	 }

	class Block {
	private ArrayList<Instruction> instructions =  new ArrayList<Instruction>();

	public void addInstruction(Instruction instruction) {
	instructions.add(instruction);
	 }

	 public void  run() {
		for (Instruction instruction: instructions) {
		instruction.run();
		  }
	 }
	 
	 }

	abstract class Instruction {
	abstract void run();
	}

	class Command  extends Instruction {
		private String com;
		private String var1;
		private String var2;
		private int x;
		private int y;

		public Command(Token com, Token var1, Token var2){
			this.com = com.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
			this.var2 = var2.image.toLowerCase();
		}

		public Command(Token com, Token var1){
			this.com = com.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
		}

		public Command(Token com){
			this.com = com.image.toLowerCase();
		}
		
		@Override
		public void run(){
			switch(com) {
			case "goto":
				x = Integer.parseInt(var1);
				y = Integer.parseInt(var2);
				world.setPostion(x, y);
				break;
			case "move":
				x = Integer.parseInt(var1);
				world.moveForward(x, false);
				break;
			case "put":
				x = Integer.parseInt(var1);
				if (var2 == "chips"){
					world.putChips(x);
				} else {
					world.putBalloons(x);
				}
				break;
			case "pick":
				x = Integer.parseInt(var1);
				if (var2 == "chips"){
					world.pickChips(x);
				} else {
					world.grabBalloons(x);
				}
				break;
			}
		}
	}

	class ProcedureCall extends Instruction {
		private Function function;
	  
	  	public ProcedureCall(Token nameFunction) {

	  	 }
	  	 
		@Override
		public void run(){

		}
	}

	class ControlStructure extends Instruction {
		private String str;
		private Condition con;
		private int var;
		private Block block1;
		private Block block2;

		public ControlStructure(Token str, Condition con, Block block1, Block block2){
			this.str = str.image.toLowerCase();
			this.con = con;
			this.block1 = block1;
			this.block2 = block2;
		}

		public ControlStructure(Token str, Condition con, Block block1){
			this.str = str.image.toLowerCase();
			this.con = con;
			this.block1 = block1;
		}

		public ControlStructure(Token str, Token var, Block block1){
			this.str = str.image.toLowerCase();
			this.var = Integer.parseInt(var.image.toLowerCase());
			this.block1 = block1;
		}

		@Override
		public void run() {
			if (str == "if") {
			  if (con.run()) {
			  block1.run();
			  } else {
				block2.run();
			  }
			} else if (str == "while") { 
			  while(con.run()) {
			    block1.run();
			    }
			} else if (str == "repeat"){
				for (int i = 0;  i < var;  i++) {
				block1.run();
				 }
			 }
		}
	}
	
	class Condition {
		private String con;
		private String var1;
		private String var2;
		private Condition subcondition;

		public Condition(Token con, Token var1, Token var2){
			this.con = con.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
			this.var2 = var2.image.toLowerCase();
		}

		public Condition(Token con, Token var1){
			this.con = con.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
		}

		public Condition(Token con, Condition subcondition){
			this.con = con.image.toLowerCase();
			this.subcondition = subcondition;
		}

		public boolean run(){
			int x;
			int y;
			boolean r = false;
			switch(con) {
			case "facing":
				if (var1 == "north"){
					r = world.facingNorth();
				} else if (var1 == "south"){
					r = world.facingSouth();
				} else if (var1 == "east"){
					r = world.facingEast();
				} else {
					r = world.facingWest();
				}
				break;
			case "canput":
				x = Integer.parseInt(var1);
				if (var2 == "chips" && x < 2){
					r = !world.chipExists();
				} else if (var2 == "balloons"){
					r = !world.containsBallons();
				}
				break;
			case "canpick":
				x = Integer.parseInt(var1);
				if (var2 == "chips" && x < 2){
					r = world.chipExists();
				} else if (var2 == "balloons"){
					r = world.countBalloons() >= x;
				}
				break;
			case "not":
				r = !subcondition.run();
				break;
			default: r = false;
		} return r; }
	}

} 


PARSER_END(Robot)

/**
 * SECTION 2: TOKENS
 */

SKIP :
{
  " " | "\r" | "\t" | "\n" | "\f"
}


TOKEN : /* Keywords */
{
  < ROBOT_R : "robot_r" >
| < VARS : "vars" >
| < PROCS : "procs" >
}

TOKEN : /* Commands */
{
  < assignTo : "assignto" >
| < goTo : "goto" >
| < move : "move" >
| < turn : "turn" >
| < face : "face" >
| < put : "put" >
| < pick : "pick" >
| < moveToThe : "movetothe" >
| < moveInDir : "moveindir" >
| < jumpToThe : "jumptothe" >
| < jumpInDir : "jumpindir" >
| < nop : "nop" >
}

TOKEN : /* Control Structures */
{
  < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < WHILE : "while" >
| < DO : "do" >
| < REPEAT : "repeat" >
}

TOKEN : /* Conditions */
{
  < facing : "facing" >
| < canPut : "canput" >
| < canPick : "canpick" >
| < canMoveInDir : "canmoveindir" >
| < canJumpInDir : "canjumpindir" >
| < canMoveToThe : "canmovetothe" >
| < canJumpToThe : "canjumptothe" >
| < not : "not" >
}

TOKEN : /* Symbols */
{
  < O_BRACKET : "[" >
| < C_BRACKET : "]" >
| < COMMA : "," >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < V_BAR : "|" >
}

TOKEN : /* Variables */
{
  < LEFT : "left" >
| < RIGHT : "right" >
| < AROUND : "around" >
| < ORIENTATION : "north" | "south" | "east" | "west" >
| < X_OBJECT : "balloons" | "chips" >
| < DIRECTION : "front" | "back" >
| < NUMBER : (<DIGIT>)+ >
| < NAME : <LETTER> (<LETTER> | <DIGIT>)* >
| < #LETTER   : ["a"-"z","A"-"Z"] >
| < #DIGIT : ["0"-"9"] >
}

/**
 * SECTION 3: PRODUCTION RULES
 */

boolean command(Console sistema) : {salida=new String();} {
  // En Discord se dijo que La declaración de variables y procedimientos es opcional, el bloque de instrucciones es obligatorio
	<ROBOT_R> (declaration())? (procedures())? blockInstructions() <EOF> 
	{variables.clear(); functions.clear(); params.clear(); return false;}
}

void declaration() : {Token var;} {
	<VARS> 
	var = <NAME> {Robot.addVariable(var);}
	(<COMMA> var = <NAME> {Robot.addVariable(var);})* 
	<SEMICOLON>
}
 
/* Functions */

void procedures() : {} {
  	<PROCS> (procedureDef())+
}

void procedureDef() : {Token function; Token var;} {
	function = <NAME> {Robot.addFunction(function);} 
	<O_BRACKET>
	<V_BAR> 
	(var = <NAME> {Robot.addParam(var);} (<COMMA> var = <NAME> {Robot.addParam(var);})*)* 
	<V_BAR>
	instruction() (<SEMICOLON> instruction())*
	<C_BRACKET>
}

Block blockInstructions() : {Block block = new Block(); Instruction ins;} {
	<O_BRACKET>
	ins = instruction() {block.addInstruction(ins); } (<SEMICOLON> ins = instruction() {block.addInstruction(ins); })*
	<C_BRACKET>
	{ return block; }
}

Block oneInstruction() : {Block block = new Block(); Instruction ins;} {
	ins = instruction() {block.addInstruction(ins); }
	{ return block; }
}

Instruction instruction() : {Instruction ins;} {
	ins = commands() { return ins; }
	| ins = procedureCall() { return ins; }
	| ins = controlStructure() { return ins; }
	
}

Command commands() : {Token com; Token var1; Token var2;} {
  	//toThe -> Direction, inDir -> Orientation
	com = <assignTo> <COLON> var1 = <NUMBER> <COMMA> var2 = <NAME> {return new Command(com, var1, var2) ;}
	| com = <goTo> <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> (var2 = <NUMBER> | var2 = <NAME> {Robot.checkVariable(var2);}) {return new Command(com, var1, var2) ;}
	| com = <move> <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) {return new Command(com, var1) ;}
	| com = <turn> <COLON> (var1 = <LEFT> | var1 = <RIGHT> | var1 = <AROUND>) {return new Command(com, var1) ;}
	| com = <face> <COLON> var1 = <ORIENTATION> {return new Command(com, var1) ;}
	| (com = <put> | com = <pick>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> var2 = <X_OBJECT> {return new Command(com, var1, var2) ;}
	| (com = <moveToThe> | com = <jumpToThe>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> (var2 = <LEFT> | var2 = <RIGHT> | var2 = <DIRECTION>) {return new Command(com, var1, var2) ;}
	| (com = <moveInDir> | com = <jumpInDir>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> var2 = <ORIENTATION> {return new Command(com, var1, var2) ;}
	| com = <nop> <COLON> {return new Command(com) ;}
}

ProcedureCall procedureCall() : {Token function; Token var; ProcedureCall call;} {
	function = <NAME> <COLON> { call = new ProcedureCall(function);}
	((var = <NUMBER> | var = <NAME> {Robot.checkVariable(var);}) (<COMMA> (var = <NUMBER> | var = <NAME> {Robot.checkVariable(var);}))*)*
}

ControlStructure controlStructure() : {Token str; Token var; Condition con; Block block1; Block block2;} {
  //En Discord se dijo que Si no se exigen corchetes en un bloque, es porque es una sola instrucción
	str = <IF> <COLON> con = condition() <THEN> <COLON> (block1 = blockInstructions() | block1 = oneInstruction()) <ELSE> <COLON> (block2 = blockInstructions() | block2 = oneInstruction()) { return new ControlStructure(str, con, block1, block2); }
	| str = <WHILE> <COLON> con = condition() <DO> <COLON> (block1 = blockInstructions() | block1 = oneInstruction()) { return new ControlStructure(str, con, block1); }
	| str = <REPEAT> <COLON> (var = <NUMBER> | var = <NAME> {Robot.checkVariable(var);}) (block1 = blockInstructions() | block1 = oneInstruction()) { return new ControlStructure(str, var, block1); }
}

Condition condition() : {Token con; Token var1; Token var2; Condition subcondition;} {
  	//toThe -> Direction, inDir -> Orientation
	con = <facing> <COLON> var1 = <ORIENTATION> {return new Condition(con, var1);}
	| (con = <canPut> | con = <canPick>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> var2 = <X_OBJECT> {return new Condition(con, var1, var2);}
	| (con = <canMoveInDir> | con = <canJumpInDir>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> var2 = <ORIENTATION> {return new Condition(con, var1, var2);}
	| (con = <canMoveToThe> | con = <canJumpToThe>) <COLON> (var1 = <NUMBER> | var1 = <NAME> {Robot.checkVariable(var1);}) <COMMA> (var2 = <LEFT> | var2 = <RIGHT> | var2 = <DIRECTION>) {return new Condition(con, var1, var2);}
	| con = <not> <COLON> subcondition = condition() { return new Condition(con, subcondition); }
}







	